#############################################################################
####
##
#W  SplittField.gi            RADIROOT package                Andreas Distler
##
##  Installs the functions to compute the splitting field of a polynomial
##
#H  @(#)$Id: SplittField.gi,v 1.0 2004/08/21 14:38:01 gap Exp $
##
#Y  2004
##


#############################################################################
##
#F  RR_BegleitMatrix( <f>, <a> )
##
##  Computes the companionmatrix of the polynomial <f> with respect to
##  the field generated by the matrix <a>
##
InstallGlobalFunction( RR_BegleitMatrix, function( f, a )
    local matrix, coeff, blockmat, deg, i, k, l;

    deg := Degree(f);
    coeff := CoefficientsOfUnivariatePolynomial(f);
    matrix := NullMat( deg*Size(a), deg*Size(a), Rationals);

    # Letzte Zeile erstellen
    for i in [ 1..deg ] do
        # Matrix, die dem i-ten Koeffizienten entspricht
        blockmat := -RR_RootInK( a, coeff[i] );
        for k in [1..Size(a)] do
            for l in [1..Size(a)] do
                matrix[(deg-1)*Size(a)+k][(i-1)*Size(a)+l] := blockmat[k][l];
            od;
        od;
    od;

    # Nebendiagonale mit Einsen fuellen
    for i in [1..(deg-1)] do
        for k in [1..Size(a)] do 
            matrix[(i-1)*Size(a)+k][i*Size(a)+k] := 1;
        od;
    od;
    	
    return matrix;
end );


#############################################################################
##
#F  RR_BlowUpMat, function( <mat>, <n> )
##
##  Computes a matrix that is <n>-times bigger than <mat> and has
##  <mat> on the <n> blocks with size of <mat> at the diagonal
##
InstallGlobalFunction( RR_BlowUpMat, function( mat, n )
    local i, j, k, Mat;

    Mat := NullMat( n * Size(mat), n * Size(mat), Rationals );
    # auf den n Diagonalbloecken werden die Nullen durch mat ersetzt
    for i in [ 1..n ] do
        for j in [ 1..Size( mat ) ] do
            for k in [ 1..Size( mat ) ] do
                Mat[ (i-1)*Size(mat)+j ][ (i-1)*Size(mat)+k ] := mat[j][k];
            od;
        od;
    od;

    return Mat;
end );


#############################################################################
##
#F  RR_MatrixField( <f>, <mat> )
##
##  Returns the matrixfield that arises from adjoining a root of the
##  polynomial <f> to the matrixfield generated by <mat>
##
InstallGlobalFunction( RR_MatrixField, function( f, mat )
    local A, B;

    # mat als Matrix in Oberkoerper
    # mat wird deg(f)-mal auf die Diagonale gesetzt 
    A := RR_BlowUpMat( mat, Degree(f) );

    # Begleitmatrix von f bzgl. des durch mat erzeugten Koerpers
    B := RR_BegleitMatrix( f, mat );

    return FieldByMatricesNC( [A, B] );
end );


#############################################################################
##
#F  RR_RootInH( <erw>, <a> )
##
##  The record <erw> contains two isomorphic fields. One generated
##  with AlgebraicExtension and the other as matrixfield. Both a
##  defined by a primitive element. This function transfers the
##  matrix <a> to it's isomorphic symbolic represenation
##
InstallGlobalFunction( RR_RootInH, function( erw, a )
    local coeff, bas, n;

    n := Size(erw.primEl);

    # Basis: 1, primEl, ... , primEl^(n-1) in Matrix umwandeln
    bas := Basis( erw.K, List( [1..n], i -> erw.primEl^(i-1) ) );

    # Koeffizienten bzgl. der standardisierten Basis
    coeff := Coefficients( bas, a );

    return Sum( [ 1..n ], i -> coeff[i] * PrimitiveElement(erw.H)^(i-1) );
end ); 
    

#############################################################################
##
#F  RR_RootInK( <primEl>, <coeff> )
##
##  Does the inverse of RR_RootInH; the fieldelement given symbolic
##  by it's external representation <coeff> is transfered in a matrix
##  of the field generated by <primEl>
##
InstallGlobalFunction( RR_RootInK, function( primEl, coeff )
    local i, mat;

    mat := NullMat( Size(primEl), Size(primEl), Rationals );
    for i in [1..Size(primEl)] do
        mat := mat +  ExtRepOfObj(coeff)[i] * primEl^(i-1);
    od;

    return mat;
end );


#############################################################################
##
#F  RR_Zerfaellungskoerper( <poly>, <erw> )
##
##  Computes the splitting field of the polynomial <poly>. In the
##  record <erw> the field is stored as matrix field as well as in a
##  symbolic represenation generated by
##  AlgebraicExtension. The roots of <poly> are also stored.  
##
InstallGlobalFunction( RR_Zerfaellungskoerper, function( poly, erw )
    local unity, matA, matB, faktoren, i, k, f, g, root, V, deg;

    faktoren := [poly];
    #roots := [ ];
 
    # Schleife bis poly in Linearfaktoren zerfaellt
    while not Degree( faktoren[ Length( faktoren ) ] ) = 1 do
    
	f := faktoren[ Length( faktoren ) ];
	erw.K := RR_MatrixField( f, erw.primEl );
	Add( erw.degs, Degree(f) );

	matA := GeneratorsOfField( erw.K )[ 1 ];;
	matB := GeneratorsOfField( erw.K )[ 2 ];;

	# Wurzelliste aktualisieren
	for i in [ 1..Length(erw.roots) ] do
	    erw.roots[i] := RR_BlowUpMat( erw.roots[i], Degree( f ) );
	od;    
	#for i in [ 1..Length(roots) ] do
	#    roots[i] := RR_BlowUpMat( roots[i], Degree( f ) );
	#od;    
	Add( erw.roots, matB );

	# Primitives Element suchen
        deg := Product( erw.degs );
	for i in [ 0..99 ] do
	    #if IsPrimitiveElement( erw.K, i * matA + matB ) then
	    #    erw.primEl := i * matA + matB;
            V := VectorSpace( Rationals,
                              List( [ 1..deg / Minimum( Factors( deg ) ) ],
                                    k -> (i * matA + matB)^(k-1) ) );
            if Coefficients( Basis( V ),
                             (i * matA + matB)^(deg/Minimum(Factors(deg))))
               = fail then
                 erw.primEl := i * matA + matB;
                 break;
	    fi;
	od;

	erw.H := AlgebraicExtension( Rationals,
		     MinimalPolynomial( Rationals, erw.primEl ) );
	Print(DefiningPolynomial(erw.H), " definierendes Poly.\n");
	
	## poly in neues H einbetten    	
	#f := UnivariatePolynomial( erw.H,
	#    One(erw.H)*CoefficientsOfUnivariatePolynomial( poly ) );
	#for i in Concatenation( erw.roots, roots ) do
	#    g := UnivariatePolynomial( erw.H,
	#	     [ -RR_RootInH( erw, i ),One(erw.H) ] );
	#    f := f/g;
	#od;

        # poly ueber neuem H faktorisieren	
	faktoren := FactorsPolynomialKant( poly, erw.H );    
	# Print( faktoren, "\n" );
	
	# Wurzeln aus neuen Linearfaktoren berechnen
        #for i in Filtered( faktoren, x -> Degree( x ) = 1 ) do
            #Add( roots, RR_RootInK( erw.primEl, 
	         #-CoefficientsOfUnivariatePolynomial( i )[ 1 ] ) );
        #od;
    od; 
    for i in faktoren do
	root := RR_RootInK( erw.primEl, 
	            -CoefficientsOfUnivariatePolynomial( i )[ 1 ] );
        if not root in erw.roots then Add( erw.roots, root ); fi;
    od;
   
    Print( Coefficients(Basis(erw.K),erw.primEl),"\n"); 
    Print( DegreeOverPrimeField(erw.H), "  Koerpergrad\n" );

    return erw;
end );


#############################################################################
##
#E












